import { Tile, TileType } from '../tiles/tile';
import { TileMod } from '../tiles/tileMod';
import { CollectorOutput, MapState, StyleState } from '../types';
import { Int64 } from '../utils/structures/int64';
import { LRU } from '../utils/structures/lru';
export interface TileDictionary {
    [key: string]: Tile;
}
export interface TileModDictionary {
    [key: string]: TileMod;
}
/**
 * Свойство, определяющее текущее направление зума. Возможные значения:
 *
 * Stationary: в данный момент зум не меняется
 * ZoomingIn: в данный момент зум увеличивается
 * ZoomingOut: в данный момент зум уменьшается
 */
export declare const enum ZoomDirection {
    Stationary = 0,
    ZoomingIn = 1,
    ZoomingOut = 2
}
/**
 * Текущий статус появления тайлов, определяет логику по которой будут добавляться тайлы на сцену
 *
 * ByOne: новые тайлы добавляются на сцену сразу после их загрузки, например, при драге или зуме
 * WaitingLayer: новые тайлы добавляются на сцену только после готовности всех тайлов во вьюпорте данного слоя, например, при селекте
 * GlobalWaiting: новые тайлы добавляются на сцену только после готовности всех данных, которые есть в карте к показу, например, при смене стиля
 */
export declare const enum TilesAppearance {
    ByOne = 0,
    WaitingLayer = 1,
    GlobalWaiting = 2
}
/**
 * Объект полностью описывающий состояние тайлового слоя.
 * ВАЖНО. В качестве значения текущего зума карты zoomLevel, рассматриваем именно стилевой зум.
 *
 * Сейчас логика отображения такая:
 * - Тайлы показываются начиная с minZoomLevel и до максимально возможного зума карты, либо до maxDisplayLevel включительно
 *   при его наличии.
 * - Данные тайлов запрашиваются только если зум находится в границах между minZoomLevel и maxZoomLevel включительно
 * - Тайлы перегенерируются в двух случаях:
 *   1. Получен новый тайл
 *   2. Изменился уровень детализации тайла. Сейчас он рассчитывается, как clamp(zoomLevel, minDetailLevel, maxDetailLevel)
 *
 * Рассмотрим, к примеру, следующий GridState:
 * {
 *      minZoomLevel: 5,
 *      maxZoomLevel: 10,
 *      minDetailLevel: 5,
 *      maxDetailLevel: 15,
 *      maxDisplayLevel: 18,
 *      ...
 * }
 *
 * - С 1 по 4 зум включительно, тайлы не запрашиваются, не генерируются и не отображаются
 * - С 5 по 10 зум включительно, запрашиваются тайлы попадающие во вьюпорт в соответствии с текущем зумом, генерируются с detailLevel равным текущему зуму и отображаются
 * - С 5 по 15 зум включительно, запрашиваются тайлы попадающие во вьюпорт в для зума maxZoomLevel, генерируются с detailLevel равным текущему зуму и отображаются
 * - С 16 по 18 зум включительно, запрашиваются тайлы попадающие во вьюпорт в для зума maxZoomLevel, генерируются с detailLevel равным maxDetailLevel и отображаются
 * - С 16 по 20 зум включительно, тайлы не запрашиваются, не генерируются и не отображаются
 * - Во всех кейсах сперва смотрим кэш. Но при изменении целой части стилевого зума в рамках от minZoomLevel до maxDetailLevel тайлы должны перезапроситься.
 *   но это не критично, так как их отдаст браузер из кэша.
 *
 * TODO: Нужно порефакторить эту штуку и вообще все ф-и связанные с ней.
 * Точно стоит удалить лишние параметры и поработать с неймингом.
 *
 * Возможный вариант:
 * {
 *      // Минимальный и максимальный зум для который есть тайлы на тайл-сервере
 *      // По умолчанию тайлы грузятся, генерируются и отображаются только если зум в этом диапазоне
 *      minZoom: number,
 *      maxZoom: number,
 *
 *      // При его наличии для зумов больших чем zoomLevel меньше либо равных maxDetailZoom,
 *      // будут сгенерированы данные тайлов с maxZoom с учетом detailLevel
 *      // Должен быть больше maxZoom, иначе в нем нет смысла. По умолчанию равен maxZoom
 *      maxDetailZoom?: number,
 *
 *      ...
 * }
 *
 * В этом морже https://gitlab.2gis.ru/WebMaps/jakarta/-/merge_requests/645 появились min[max]detailLevel
 */
export interface GridState {
    /**
     * Тип тайлов
     */
    type: TileType;
    /**
     * ID источника данных,
     * помогает сформировать уникальный префикс "TileType_sourceId" из которого будет получаться уникальный ключ для каждого тайла для хранения его элементов в лейблинге.
     */
    sourceId: number;
    /**
     * ID тайлового слоя.
     * Является уникальным значением среди всех тайловых слоев в движке.
     * Используется для идентификации ключей тайлов в рамках одного источника (DefaultSource).
     */
    tileLayerId: number;
    /**
     * Внутренний ID стиля, с которым сейчас должны работать тайлы.
     * Если меняется, то тайлы перегенерируются.
     */
    styleId: number;
    /**
     * Ревизия стиля, которая меняется любом его изменении.
     * Если меняется, то тайлы перегенерируются.
     */
    styleRevision: number;
    /**
     * Стейт стиля. Если меняется, то тайлы перегенерируются.
     */
    styleState: StyleState;
    /**
     * Минимальное значение зума для которого существуют данные тайлов.
     * С этого же зума начинаем отображать тайлы.
     */
    minZoomLevel: number;
    /**
     * Максимальное значение зума для которого существуют данные тайлов.
     */
    maxZoomLevel: number;
    /**
     * Минимальное значение зума для которого будет перегенерироваться тайлы.
     *
     * TODO: Думаю стоит выпилить minDetailLevel, и брать вместо него minZoomLevel.
     * Это значение не имеет никакого смысла, так как нет никакого смысла в том,
     * чтобы отображать на меньших зумах тайлы от больших. Более того, во всем проекте
     * это значение равно minZoom
     */
    minDetailLevel: number;
    /**
     * Максимальное значение зума, для которого будет пререгенерироваться тайлы.
     * Этот параметр нужен чтобы иметь возможность отобразить тайлы меньшего зума для большего зума карты.
     * Значение должно быть больше либо равным maxZoomLevel. Задавать значения меньше бессмысленно,
     * лучше просто поменять maxZoomLevel.
     *
     * TODO: Сделать необязательным с фолбеком на maxZoomLevel.
     */
    maxDetailLevel: number;
    /**
     * Текущий статус появления тайлов, определяет логику по которой будут добавляться тайлы на сцену
     */
    tilesAppearance: TilesAppearance;
    /**
     * Если true, то означает, что запущен процесс обновления данных в источнике через вызов метода source.setData(),
     * в рамках которого все лейблы тайлов перестают анимированно появляться или скрываться.
     * Флаг выставляется снова в false, после как:
     * 1. завершился процесс обновления данных
     * 2. последние лейблы в рамках этого процесса отправились в лейблинг
     */
    stopLabelAnimation: boolean;
    /**
     * Хранит все моды показанные пользователю
     */
    displayedMods: TileModDictionary;
    /**
     * Массив geo id, которые должны быть выделены на карте
     */
    selectedIds: Int64[];
    /**
     * Хранит готовые тайлы, которые на текущем экране не отображаются, но их данные загружены в видеокарту
     */
    tileModsCache: LRU<TileMod>;
    tileModsCacheMaxCount: number;
    /**
     * Хранит значение зума, которое было в начале его изменения
     */
    zoomStartZoom: number;
    /**
     * Хранит текущее направление зума
     */
    zoomDirection: ZoomDirection;
    /**
     * Хранит округленный стилевой зум, который показываем в данный момент
     */
    zoomLevel: number;
    /**
     * Объект, хранящий ключи тайлов, попадающих в данный момент во вьюпорт
     */
    viewportTiles: string[];
    /**
     * Объект, хранящий все данные о тайлах
     */
    tiles: TileDictionary;
    /**
     * Ссылка на стейт карты
     * TODO: Стейта карты тут быть не должно! Это противоречит всякой логике инкапсуляции. Нужно выпилить с рефакторингом тикеров.
     */
    mapState: MapState;
}
export interface GenerationResult {
    styleId: number;
    metatileHash: number;
    regionId: number;
    collectorOutput: CollectorOutput;
}
export interface GeneratedTileOptions {
    generateOnlySelectedPoi?: boolean;
    generateOnlyHoveredPoi?: boolean;
    areTileBoundsVisible?: boolean;
}
